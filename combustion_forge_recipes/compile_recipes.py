#!/usr/bin/env python3

import json
import logging
import os
import os.path as path
from copy import deepcopy
from glob import glob
from io import TextIOWrapper

################################################################################
# This file is used to compile the recipes for the combustion forge in 
#   {combustion_forge_recipe_directory} into mcfunction files in 
#   {recipe_output_directory} that will handle checking for and producing the 
#   results of the recipes.
#
# If any recipes, or the config below, have been changed or added, make sure to 
#   rerun this script (in the project directory) and commit the changes to the
#   repository.
# Note: If a recipe has been removed, this will not clear them from 
#   {recipe_output_directory}. Do it yourself, peasant.
#

################################################################################
# CONFIG START                                                                 #
################################################################################
# Where the uncompiled combustion forge recipes are located. Relative path from
#   the prject directory.
combustion_forge_recipe_directory = r'combustion_forge_recipes/recipes/'
# Where to output the compiled recipes to. Relative path from 
#   {combustion_forge_recipe_directory}.
recipe_output_directory = r'../../ExplosiveUtilities-DP/data/xplsvtlts/functions/combustion_forge/recipes/generated/'
# The file path to write out the function tag that will run all combustion forge
#   recipes. Relative path from {combustion_forge_recipe_directory}.
recipe_function_tag_file_path = r'../../ExplosiveUtilities-DP/data/xplsvtlts/tags/functions/combustion_forge_recipes/generated.json'
# The id for the function that decrements each slot of the combustion forge's
#   crafting grid.
decrement_crafting_grid_function_id = r'xplsvtlts:combustion_forge/recipes/decrement_crafting_grid'
# The resource id of the directory where the generation function files are 
#   located. Must end in a '/'.
recipe_function_directory_id = r'xplsvtlts:combustion_forge/recipes/generated/'
# The scoreboard to use to read and store to and from the variables used by the
#   recipes.
variable_storage_scoreboard = r'xplsvtlts'

logging_level = logging.NOTSET
################################################################################
# CONFIG END                                                                   #
################################################################################



# Basic type definition for minecraft items.
Item = dict
# Type definition for the patterns of shaped forge recipes.
ShapedPattern = 'list[list[Item]]'

# The item form of air, used to fill the empty spaces of shaped patterns.
item_air: Item = { r"item": r"minecraft:air" }



def decode_shaped_recipe_pattern(recipe_json: object) -> ShapedPattern:
    ''' Replaces the letter placeholders in the recipe pattern with the items
        they map to and returns the decoded pattern. '''
    item_keys = recipe_json["key"]
    decoded_pattern = []

    for row in recipe_json["pattern"]:
        decoded_row = []
        for key in row:
            if key == ' ':
                decoded_row.append(item_air)
            else:
                decoded_row.append(item_keys[key])

        decoded_pattern.append(decoded_row)

    return decoded_pattern

def create_pattern_arrangments(decoded_pattern: ShapedPattern) -> 'list[ShapedPattern]':
    ''' Creates a list of all possible arrangements of the given pattern, 
        filling in empty spaces with air. '''
    height, width = len(decoded_pattern), len(decoded_pattern[0])
    empty_vertical_spaces, empty_horizontal_spaces = 3 - height, 3 - width

    pattern_arrangements = [] 

    # Generates every possible arrangement of the pattern by shifting it through
    #   the crafting grid.
    for delta_y in range(0, empty_vertical_spaces + 1):
        for delta_x in range(0, empty_horizontal_spaces + 1):
            shifted_pattern = deepcopy(decoded_pattern)

            # Fills in empty spots of pattern with air.
            for row in range(0, height):
               shifted_pattern[row] = [item_air] * delta_x + shifted_pattern[row] + [item_air] * (empty_horizontal_spaces - delta_x)
            shifted_pattern = [[item_air,item_air,item_air]] * (empty_vertical_spaces - delta_y) + shifted_pattern + [[item_air,item_air,item_air]] * delta_y

            pattern_arrangements.append(shifted_pattern)

    return pattern_arrangements

def write_shaped_recipe_mcfunction_code( output_file: TextIOWrapper, recipe_function_id: str, recipe_json: object):
    ''' Writes out the code for the given shaped recipe. '''
    output_file.writelines([ '################################################################################\n'
                           , '# AUTOGENERATED FILE - DO NOT EDIT.                                            #\n'
                           , '# CHANGES WILL BE OVERWRITTEN.                                                 #\n'
                           , '################################################################################\n'
                           , '\n'
                           , '##\n'
                           , '# A compiled shaped recipe for the combustion forge, generated using\n'
                           , '#   {PROJECT_DIR}/combustion_forge_recipes/compile_recipes.py\n'
                           , '#\n'
                           , '# Tests for the recipe pattern in each possible arrangement. If found, the item\n'
                           , '#   will be crafted up to 16 times, consuming the required ingredients and\n'
                           , '#   producing the item as an entity inside the forge.\n'
                           , '#\n'
                           , '# Parameters:\n'
                           , '#   @s - the combustion forge core.\n'
                           , '#   Location - at @s\n'
                           , f'#   _items_crafted (scoreboard: {variable_storage_scoreboard}) - Initialize to 0. Keeps track of the\n'
                           , '#        number of items crafted to stop when the limit per combustion forge\n'
                           , '#        operation is reached.\n'
                           , f'#   _found_recipe (scoreboard: {variable_storage_scoreboard}) - Initialize to 0. Used to skip further\n'
                           , '#        recipes once one has been found.\n'
                           , '#\n'
                           , '# Returns:\n'
                           , f'#   _items_crafted (scoreboard: {variable_storage_scoreboard}) - the number of items crafted.\n'
                           , f'#   _found_recipe (scoreboard: {variable_storage_scoreboard}) - whether a recipe was found.\n'
                           , '#\n'
                           , '\n'])
    
    # Combustion forge can make up to 16 items.
    output_file.write(f'execute if score _items_crafted {variable_storage_scoreboard} matches 16.. run return 0\n')
    # If we already found the recipe the forge contains we don't need to try any
    #   other ones.
    output_file.write(f'execute if score _found_recipe {variable_storage_scoreboard} matches 1 run return 0\n')
    output_file.write('\n\n\n')

    
    pattern_arrangements = create_pattern_arrangments(decode_shaped_recipe_pattern(recipe_json))

    result_item_data = recipe_json["result"]
    result_item_id = result_item_data["item"]
    result_item_count = result_item_data.get("count", 1)
    result_item_tag_string = f',tag:{result_item_data["nbt"]}' if result_item_data.get("nbt") is not None else '' 

    pattern_number = 1
    # Writes code to test and craft each possible arrangement of the recipe on
    #   the crafting grid one by one.
    for pattern in pattern_arrangements:
        # Used to count number of valid ingredients to see if the recipe 
        #   is present in the grid.
        output_file.write(f'## Pattern {pattern_number}.\n')
        output_file.write(f'scoreboard players set _valid_ingredient_count {variable_storage_scoreboard} 0\n')

        # Tests if crafting pattern arrangement is present on the 
        #   crafting grid.
        for crafting_grid_z in range(-1, 2):
            for crafting_grid_x in range(-1, 2):
                ingredient_item_data = pattern[crafting_grid_z + 1][crafting_grid_x + 1]
                ingredient_item_ids = ingredient_item_data["item"] if type(ingredient_item_data["item"]) is list else [ingredient_item_data["item"]]
                item_tag_string = f',tag:{ingredient_item_data["nbt"]}' if ingredient_item_data.get("nbt") is not None else '' 

                output_file.write(f'# Item {(crafting_grid_x + 1) + (crafting_grid_z + 1) * 3 + 1}.\n')
                for ingredient_item_id in ingredient_item_ids:
                    if ingredient_item_id != 'minecraft:air':
                        output_file.write(f'execute if block ^{crafting_grid_x} ^1 ^{crafting_grid_z} minecraft:furnace{{Items:[{{Slot:0b,id:"{ingredient_item_id}"{item_tag_string}}}]}} run scoreboard players add _valid_ingredient_count {variable_storage_scoreboard} 1\n')
                    else:
                        output_file.write(f'execute unless block ^{crafting_grid_x} ^1 ^{crafting_grid_z} minecraft:furnace{{Items:[{{Slot:0b}}]}} run scoreboard players add _valid_ingredient_count {variable_storage_scoreboard} 1\n')

        # If it is present, we can consume the ingredients,
        output_file.write('# Consume ingredients.\n')
        output_file.write(f'execute if score _valid_ingredient_count {variable_storage_scoreboard} matches 9 run function {decrement_crafting_grid_function_id}\n')
        #   produce the resulting item(s),
        output_file.write('# Create result.\n')
        output_file.write(f'execute if score _valid_ingredient_count {variable_storage_scoreboard} matches 9 run summon minecraft:item ~ ~ ~ {{Item:{{id:"{result_item_id}",Count:{result_item_count}b{result_item_tag_string}}}}}\n')
        output_file.write(f'execute if score _valid_ingredient_count {variable_storage_scoreboard} matches 9 run scoreboard players add _items_crafted {variable_storage_scoreboard} 1\n')
        #   and recursively run the recipe now that is has been found.
        output_file.write('# Recipe found, repeat until done.\n')
        output_file.write(f'execute if score _valid_ingredient_count {variable_storage_scoreboard} matches 9 run function {recipe_function_id}\n')
        output_file.write('\n\n\n')

        pattern_number += 1


    # Temporary variable cleanup.
    output_file.write(f'scoreboard players reset _valid_ingredient_count {variable_storage_scoreboard}\n')
    # If the item was able to be crafted, we mark that the recipe was found and
    #   skip the other recipes.
    output_file.write('# Mark that the recipe was found if it was able to be crafted.\n')
    output_file.write(f'execute if score _items_crafted {variable_storage_scoreboard} matches 1.. run scoreboard players set _found_recipe {variable_storage_scoreboard} 1\n')



def write_recipe_mcfunction_code(output_directory: str, recipe_name: str, recipe_function_id: str, recipe_json: object) -> bool:
    ''' Attempts to write the code for the given recipe to the specified output
        file and returns whether it succeded. '''
    output_file_path = path.join(output_directory, recipe_name + '.mcfunction')
    recipe_type = recipe_json["type"]

    if recipe_type == 'crafting_shaped':
        with open(output_file_path, 'w') as output_file:
            write_shaped_recipe_mcfunction_code( output_file
                                               , recipe_function_id
                                               , recipe_json)

        logging.info(f"Wrote shaped recipe '{recipe_name}' -> '{path.abspath(output_file_path)}'")
        return True

    else:
        logging.error(f"'{recipe_type}' is not a supported recipe type! Skipped writing recipe '{recipe_name}' -> '{path.abspath(output_file_path)}'", )
        return False

def write_recipe_function_tag_json(output_file_path: str, recipe_function_ids: 'list[str]'):
    ''' Writes out the recipe function ids into a tag so they can all be called
        by the combustion forge crafting system. '''
    with open(output_file_path, 'w') as output_file:
        output_file.write('{\n')
        output_file.write('\t"values": [\n')

        if len(recipe_function_ids) > 0:
            for i in range(0, len(recipe_function_ids) - 1):
                output_file.write(f'\t\t"{recipe_function_ids[i]}",\n')
            output_file.write(f'\t\t"{recipe_function_ids[-1]}"\n')

        output_file.write('\t]\n')
        output_file.write('}\n')

        logging.info(f'Wrote out recipe function ids into tag json file -> {path.abspath(output_file_path)}')


def main():
    logging.getLogger().setLevel(logging_level)


    # Changing directory into the recipe directory makes messing with the recipe
    #   file paths 1 million times easier.
    os.chdir(combustion_forge_recipe_directory)
    recipe_file_paths = glob(r'**.json', recursive=True)


    recipe_function_ids = []
    os.makedirs(recipe_output_directory, exist_ok=True)

    # TODO make JSON validator for recipes.
    # TODO Add shapeless recipes.
    for recipe_file_path in recipe_file_paths:
        recipe_directory_path, recipe_file_name = path.split(recipe_file_path)
        recipe_name = recipe_file_name.replace('.json', '')
        recipe_function_id = recipe_function_directory_id + path.join(recipe_directory_path, recipe_name)

        with open(recipe_file_path, 'rb') as recipe_byte_stream:
            success = write_recipe_mcfunction_code( path.join(recipe_output_directory, recipe_directory_path)
                                                  , recipe_name
                                                  , recipe_function_id
                                                  , json.loads(recipe_byte_stream.read()))
            
        if success:
            recipe_function_ids.append(recipe_function_id)

    os.makedirs(path.split(recipe_function_tag_file_path)[0], exist_ok=True)
    write_recipe_function_tag_json(recipe_function_tag_file_path, recipe_function_ids)

if __name__ == '__main__':
    main()